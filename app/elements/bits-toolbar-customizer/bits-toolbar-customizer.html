<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../base-message-center/base-message-center.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">

<!-- import global object TOOLBAR_CUSTOMIZER with query definitions-->
<script type="text/javascript" src="./bits-toolbar-customizer-constants.js"></script>

<dom-module id="bits-toolbar-customizer">
  <template>
    <style>
      :host {
        display: block;
      }

      .content {
        margin-left: 0px;
        max-width: 480px;
      }

    </style>

    <!-- Sample button. Place desired buttons here, with attached listeners -->
    <paper-icon-button
      id="icon"
      icon="icons:grade"
      title="Customized Button">
    </paper-icon-button>

  </template>
  <script>
  ((global) => {
    'use strict';

    const BreakException = {};

    const REQUESTS = TOOLBAR_CUSTOMIZER.REQUESTS;

    Polymer({

      is: 'bits-toolbar-customizer',

      behaviors: [global.Bits.BaseMessageCenterBehavior],

      properties: {
        count: {
          type: Number,
          value: 0
        },
        matches: {
          type: Number,
          value: 0
        }
      },

      ready: function() {
        // It turns out, the element is not really ready when ready is called
        const poll = setInterval( () => {
          if (this.parentElement) {
            clearTimeout(poll);
            const toolbar = this._findToolbar(this.parentElement);
            this.sendRequest(REQUESTS.GET_CUSTOMIZATIONS)
            .then ((data) => {
              if (data && data.toolbar) {
                this._deepSearch(toolbar, data.toolbar,
                  (node, toHide) => {
                    toHide.display = 'none';
                    // console.log(`hide ${toHide.id}`);
                  }
                );
              }
              if (data && data.ownerDocument) {
                this._deepSearch(this.ownerDocument, data.ownerDocument,
                  (node, toHide, nextQuery) => {
                    if (nextQuery) {
                      this._deepSearch(node, nextQuery,
                      (node, toHide) => {
                        toHide.display = 'none';
                      });
                    } else {
                      toHide.display = 'none';
                    }
                    // console.log(`hide ${toHide.id}`);
                  }
                );
              }
            });
            /* Hide entire sidebar. We hode the sidebar itself (tagname = 'base-home')
               and the category item 'Home' that appears in the gallery. */
          //   this._deepSearch(this.ownerDocument, [
          //     /* The Home sidebar. Defined in base-home.html.*/
          //     [
          //       [ 'tagName', 'base-home', null,
          //         /* If this is null, hide base-home. Otherwise, execute this query on base-home.
          //         However, this has a flaw. The hidden items will still appear after clicking the
          //         "Home" link in the gallery, but will be hidden if you refresh the page.*/
          //         [
          //           [
          //             /* See computeSidebar(user) in base-home.html */
          //             ['textContent', 'Activity', 'parentNode.style']
          //           ]
          //         ]
          //       ]
          //     ],
          //     // [
          //     //   // The Home link in the gallery. Added in base-gallery.html.
          //     //   ['textContent', 'Home', 'parentNode.parentNode.host.style'],
          //     //   ['parentNode.parentNode.host.tagName', 'base-gallery-category', 'parentNode.parentNode.host.style']
          //     // ]
          //   ],
          //   (node, toHide, nextQuery) => {
          //     if (nextQuery) {
          //       this._deepSearch(node, nextQuery,
          //       (node, toHide) => {
          //         toHide.display = 'none';
          //         console.log(`hide ${toHide.id} after ${this.count} recursive searches`);
          //         this.count = 0;
          //       });
          //     } else {
          //       toHide.display = 'none';
          //       console.log(`hide ${toHide.id} after ${this.count} recursive searches`);
          //       this.count = 0;
          //     }
          //
          //
          //   });
          //   const toolbar = this._findToolbar(this.parentElement);
          //   toolbar && this._deepSearch(toolbar, [
          //     // Power menu, defined in 'base-system-power-control.html'
          //     // [
          //     //   ['id', 'menu'],
          //     //   ['parentNode.host.tagName', 'base-system-power-control']
          //     // ],
          //     // BITS label in toolbar next to gallery, defined in base-toolbar.html
          //     // [
          //     //   ['textContent', 'BITS'],
          //     //   ['parentNode.parentNode.tagName', 'app-toolbar']
          //     // ],
          //     // Stack icon on left side of toolbar, defined in base-toolbar.html
          //     // [
          //     //   ['id', 'gallery'],
          //     //   ['tagName', 'paper-icon-button']
          //     // ],
          //     // Power menu items, defined in 'base-system-power-control.html'
          //     // [
          //     //   ['tagName', 'paper-item'],
          //     //   ['textContent', 'Power off']
          //     // ],
          //     // [
          //     //   ['tagName', 'paper-item'],
          //     //   ['textContent', 'Reboot']
          //     // ]
          //   ],
          //   (node, toHide) => {
          //     toHide.display = 'none';
          //     console.log(`hide ${toHide.id} after ${this.count} recursive searches`);
          //     this.count = 0;
          //   });
          }
        }, 100)
      },

      _findToolbar(parent) {
        while(parent !== null && String(parent.localName).toLowerCase() !== 'base-toolbar') {
          if(parent.parentElement === null) {
            if(parent.shadowRoot.host) {
              parent = parent.shadowRoot.host.parentNode.host;
            } else {
              parent = null;
            }
          } else {
            parent = parent.parentElement;
          }
        }
        return parent;
      },

      _deepSearch(parent, query, cb) {
        try {
          this.count++;
          let toHide = {};
          let nextQuery = {};
          if (this._match(parent, query, toHide, nextQuery)) {
            cb(parent, toHide.item, nextQuery.item);
            if (++this.matches >= query.length) {
              throw BreakException;
            }
          }
          parent.childNodes.forEach( (node) => {
            let toHide = {};
            let nextQuery = {};
            if (this._match(node, query, toHide, nextQuery)) {
              cb(node, toHide.item, nextQuery.item)
              if (++this.matches >= query.length) {
                throw BreakException;
              }
            } else {
              this._deepSearch(node, query, cb);
            }
          });
          if (parent.shadowRoot) {
            parent.shadowRoot.childNodes.forEach( (node) => {
              let toHide = {};
              let nextQuery = {};
              if (this._match(node, query, toHide, nextQuery)) {
                cb(node, toHide.item, nextQuery.item);
                if (++this.matches >= query.length) {
                  throw BreakException;
                }
              } else {
                this._deepSearch(node, query, cb);
              }
            });
          }
        } catch (e) {
          if (e != BreakException) {
            throw e;
          }
        }
      },

      _match(node, query, toHide, nextQuery) {
        let found;
        try {
          query.forEach( (q) => {
            found = true;
            q.forEach( (kv) => {
              try {
                let obj = this._getNestedObject(node, kv[0]);
                if (typeof obj != 'string' || obj.length == 0 || obj.toLowerCase() !== String(kv[1]).toLowerCase()) {
                    found = false;
                } else {
                  toHide.item = this._getNestedObject(node, kv[2] ? kv[2] : 'style');
                  nextQuery.item = kv[3] ? kv[3] : null;
                }
              } catch (e) {
                found = false;
              }
            });
            // if (found) {
            //   throw BreakException;
            // }
          });
        } catch (e) {
          // PASS
        }
        return found;
      },

      _getNestedObject (object, path) {
        return path.split('.').reduce( (accum, value) => accum[value], object);
      }
    });

  })(window);
  </script>
</dom-module>
