<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../base-message-center/base-message-center.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">

<!-- import global object TOOLBAR_CUSTOMIZER with query definitions-->
<script type="text/javascript" src="./bits-toolbar-customizer-queries.js"></script>

<dom-module id="bits-toolbar-customizer">
  <template>
    <style>
      :host {
        display: block;
      }

      .content {
        margin-left: 0px;
        max-width: 480px;
      }

    </style>

    <!-- Sample button. Place desired buttons here, with attached listeners -->
    <paper-icon-button
      id="icon"
      icon="icons:grade"
      title="Customized Button">
    </paper-icon-button>

  </template>
  <script>
  ((global) => {
    'use strict';

    const BreakException = {};

    const REQUESTS = TOOLBAR_CUSTOMIZER.REQUESTS;

    const EVENTS = TOOLBAR_CUSTOMIZER.EVENTS;

    Polymer({

      is: 'bits-toolbar-customizer',

      behaviors: [global.Bits.BaseMessageCenterBehavior],

      properties: {
        count: {
          type: Number,
          value: 0
        },
        matches: {
          type: Number,
          value: 0
        }
      },

      ready: function() {
        // It turns out, the element is not really ready when ready is called
        const poll = setInterval( () => {
          if (this.parentElement && typeof this._queries != 'undefined') {
            clearTimeout(poll);
            this._setCustomizations(this.parentElement);
          }
        }, 500);

        this.sendRequest(REQUESTS.GET_CUSTOMIZATIONS)
        .then ( (data) => {
          this._queries = data.queries;
        });
        this.addSocketEventListener(EVENTS.UPDATE_CUSTOMIZATIONS, this._onUpdateCustomizations.bind(this));
      },

      _setCustomizations(parentElement) {
        if (!this._toolbar) {
          this._toolbar = this._findToolbar(parentElement);
        }
        // this._toolbar.style.display = 'none';
        // let parent = this._toolbar.parentElement;
        // parent.style.display='none';
        // parent.parentElement.resetLayout();
        // console.log(`parent element ${parent.tagName}`);
        // console.log(`grandparent element ${parent.parentNode.tagName}`);
        // return;
        if (this._queries && this._queries.toolbar) {
          this._queries.toolbar.forEach( (query) => {
            this._deepSearch(this._toolbar, [query],
              (setter) => {
                if ('value' in setter) {
                  setter.baseObj[setter.node] = setter.value;
                } else if ('call' in setter && setter.call in setter.baseObj) {
                  const args = setter.args ? null : {...setter.args};
                  setter.baseObj[setter.call]();
                }
              }
            );
          });

        }
        if (this._queries && this._queries.ownerDocument) {
          this._deepSearch(this.ownerDocument, this._queries.ownerDocument,
            (setter, subQueries, node) => {
              if (subQueries) {
                subQueries.forEach( (search) => {
                  this._deepSearch(node, [[search]],
                  (setter) => {
                    if ('value' in setter) {
                      setter.baseObj[setter.node] = setter.value;
                    } else if ('call' in setter && setter.call in setter.baseObj) {
                    const args = setter.args ? null : {...setter.args};
                    setter.baseObj[setter.call]();
                    }
                  });
                });
              } else {
                if ('value' in setter) {
                  setter.baseObj[setter.node] = setter.value;
                } else if ('call' in setter && setter.call in setter.baseObj) {
                  const args = setter.args ? null : {...setter.args};
                  setter.baseObj[setter.call]();
                }
              }
            }
          );
        }
      },

      _findToolbar(parent) {
        while(parent !== null && String(parent.localName).toLowerCase() !== 'base-toolbar') {
          if(parent.parentElement === null) {
            if(parent.shadowRoot.host) {
              parent = parent.shadowRoot.host.parentNode.host;
            } else {
              parent = null;
            }
          } else {
            parent = parent.parentElement;
          }
        }
        return parent;
      },

      _deepSearch(parent, query, cb) {
        try {
          this.count++;
          let setter = {};
          let subQueries = {};
          if (this._match(parent, query, setter, subQueries)) {
            cb(setter.setter, subQueries.items, parent);
            if (++this.matches >= query.length) {
              // throw BreakException;
            }
          }
          parent.childNodes.forEach( (node) => {
            let setter = {};
            let subQueries = {};
            if (this._match(node, query, setter, subQueries)) {
              cb(setter.setter, subQueries.items, node)
              if (++this.matches >= query.length) {
                // throw BreakException;
              }
            } else {
              this._deepSearch(node, query, cb);
            }
          });
          if (parent.shadowRoot) {
            parent.shadowRoot.childNodes.forEach( (node) => {
              let setter = {};
              let subQueries = {};
              if (this._match(node, query, setter, subQueries)) {
                cb(setter.setter, subQueries.items, node);
                if (++this.matches >= query.length) {
                  // throw BreakException;
                }
              } else {
                this._deepSearch(node, query, cb);
              }
            });
          }
        } catch (e) {
          if (e != BreakException) {
            throw e;
          }
        }
      },

      _match(node, query, setter, subQueries) {
        let found;
        setter.setter = {};
        try {
          query.forEach( (q) => {
            found = true;
            q.forEach( (search) => {
              try {
                let obj = this._getNestedObject(node, search.key);
                if (typeof obj != 'string' || obj.length == 0 || obj.toLowerCase() !== String(search.value).toLowerCase()) {
                    found = false;
                } else {
                  setter.setter = {
                    baseObj: this._getNestedObject(node, search.setter ? search.setter.path : 'style'),
                    node: search.setter ? search.setter.node : 'display',
                    value: search.setter ? search.setter.value : 'none',
                  };
                  if (search.setter && search.setter.call) {
                    setter.setter.call = search.setter.call;
                    if (search.setter.args) {
                      setter.setter.args = search.setter.args;
                    }
                    delete setter.setter.value
                  }
                  if (search.subquery) {
                    subQueries.items = search.subquery;
                  }
                }
              } catch (e) {
                // console.log(`EXCEPTION ${e}`)
                found = false;
              }
            });
            if (found) {
              throw BreakException;
            }
          });
        } catch (e) {
          // PASS
        }
        return found;
      },

      _getNestedObject (object, path) {
        return path.split('.').reduce( (accum, value) => accum[value], object);
      },

      _onUpdateCustomizations(data) {
        this._queries = data.queries;
        this._setCustomizations(this.parentElement);
      }
    });

  })(window);
  </script>
</dom-module>
